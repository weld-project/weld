
use std::str::FromStr;

use lalrpop_util::ParseError;

use weld_ast::BinOpKind::*;
use weld_ast::ScalarKind::*;
use weld_ast::ExprKind::*;
use weld_ast::Parameter;
use weld_ast::Symbol;
use weld_ast::partial_types::*;
use weld_ast::partial_types::PartialType::*;
use weld_ast::partial_types::PartialBuilderKind::*;
use weld_ast::program::*;

grammar["LALR(1)"];

extern {
    // Source location and error types returned by this parser. 
    type Location = usize;
    type Error = &'static str;
}

pub program = Program;    // Expose the nicer name parse_program instead of parse_Program

pub expr: PartialExpr = <e:Expr> => *e;

pub macros = <(<Macro> ";")*>;

pub Type: Box<PartialType> = {
    "?" => Box::new(Unknown),   // Don't really need this in the grammar but it's nice for testing
    "bool" => Box::new(Scalar(Bool)),
    "i32" => Box::new(Scalar(I32)),
    "i64" => Box::new(Scalar(I64)),
    "f32" => Box::new(Scalar(F32)),
    "f64" => Box::new(Scalar(F64)),
    "vec" "[" <t:Type> "]" => Box::new(Vector(t)),
    "{" <ts:CommaSep<Type>> "}" => Box::new(Struct(ts.into_iter().map(|b| *b).collect())),
    "appender" "[" <t:Type> "]" => Box::new(Builder(Appender(t))),
};

Program: Program = {
    <macros:(<Macro> ";")*> <body:Expr> => Program { macros: macros, body: *body }
};

Macro: Macro = {
    "macro" <n:Name> "(" <p:CommaSep<Name>> ")" "=" <e:SumExpr> => {
        Macro { name: n, parameters: p, body: *e }
    }
};

Expr: Box<PartialExpr> = {
    Lambda,
    LetExpr
};

Lambda: Box<PartialExpr> = {
    "|" <p:CommaSep<Parameter>> "|" <e:Expr> => expr_box(Lambda(p, e))
};

Parameter: PartialParameter = {
    <n:Name> <t:(":" <Type>)?> => Parameter { name: n, ty: t.map(|b| *b).unwrap_or(Unknown) }
};

LetExpr: Box<PartialExpr> = {
    "let" <s:Name> <t:(":" <Type>)?> "=" <value:SumExpr> ";" <body:Expr> => {
        let mut res = expr_box(Let(s, value, body));
        if let Some(t) = t {
            res.ty = *t;
        }
        res
    },
    SumExpr
};

SumExpr: Box<PartialExpr> = {
    <l:SumExpr> "+" <r:AscribeExpr> => expr_box(BinOp(Add, l, r)),
    <l:SumExpr> "-" <r:AscribeExpr> => expr_box(BinOp(Subtract, l, r)),
    <DotExpr>
};

DotExpr: Box<PartialExpr> = {
    <d:DotExpr> "." <i:r"[0-9]+"> =>? {
       match u32::from_str(i) {
           Ok(i) => Ok(expr_box(GetField(d, i))),
           Err(_) => Err(ParseError::User { error: "bad field index" })
       }
    },
    ApplyExpr
};

ApplyExpr: Box<PartialExpr> = {
    <f:Term> "(" <p:CommaSep<Expr>> ")" =>
        expr_box(Apply(f, p.into_iter().map(|b| *b).collect())),
    AscribeExpr
};

AscribeExpr: Box<PartialExpr> = {
    <term:Term> ":" <ty:Type> => {
        let mut term = term;
        term.ty = *ty;
        term
    },
    Term
};

Term: Box<PartialExpr> = {
    BoolLiteral,
    I32Literal,
    I64Literal,
    F32Literal,
    F64Literal,
    Ident,
    MakeVector,
    MakeStruct,
    If,
    NewBuilder,
    Merge,
    Result,
    For,
    "(" <Expr> ")",
};

// Integers can be represented in decimal, octal, binary, or hex.
I32LiteralStr: &'input str = {
    r"[0-9]+",
    r"0b[0-1]+",
    r"0o[0-7]+",
    r"0x[a-fA-F0-9]+",
};

// Longs are suffixed with the 'L' character.
I64LiteralStr: &'input str = {
    r"[0-9]+[lL]",
    r"0b[0-1]+[lL]",
    r"0o[0-7]+[lL]",
    r"0x[a-fA-F0-9]+[lL]",
};

// Floats are suffixed with the 'F' character.
F32LiteralStr: &'input str = {
    r"[0-9]+\.[0-9]+([eE][0-9]+)?[fF]",
    r"[0-9]+[eE][0-9]+[fF]",
};

F64LiteralStr: &'input str = {
    r"[0-9]+\.[0-9]+([eE][0-9]+)?",
    r"[0-9]+[eE][0-9]+",
};

I32Literal: Box<PartialExpr> = {
    <s:I32LiteralStr> =>? {
        let o = s.to_string();
        // Extract the radix to parse the string.
        let radix = if o.contains("0x") {
            16
        } else if o.contains("0o") {
            8
        } else if o.contains("0b") {
            2
        } else {
            10
        };
        let parsed = if radix == 10 {
            i32::from_str(s)
        } else {
            i32::from_str_radix(&s[2..], radix)
        };
        match parsed {
            Ok(v) => Ok(expr_box(I32Literal(v))),
            Err(_) => Err(ParseError::User { error: "bad i32 literal" })
        }
    }
};

I64Literal: Box<PartialExpr> = {
    <s:I64LiteralStr> =>? {
        // Parse out the trailing 'L'.
        let s = &s[0 .. s.len()-1];
        let o = s.to_string();
        // Extract the radix to parse the string.
        let radix = if o.contains("0x") {
            16
        } else if o.contains("0o") {
            8
        } else if o.contains("0b") {
            2
        } else {
            10
        };
        let parsed = if radix == 10 {
            i64::from_str(s)
        } else {
            i64::from_str_radix(&s[2..], radix)
        };
        match parsed {
            Ok(v) => Ok(expr_box(I64Literal(v))),
            Err(_) => Err(ParseError::User { error: "bad i64 literal" })
        }
    }
};

F32Literal: Box<PartialExpr> = {
    <s:F32LiteralStr> =>?    {
        // Parse out the trailing 'F'.
        let s = &s[0 .. s.len()-1];
        match f32::from_str(s) {
            Ok(v) => Ok(expr_box(F32Literal(v))),
            Err(_) => Err(ParseError::User { error: "bad f32 literal" })
        }
    }
};

F64Literal: Box<PartialExpr> = {
    <s:F64LiteralStr> =>? match f64::from_str(s) {
        Ok(v) => Ok(expr_box(F64Literal(v))),
        Err(_) => Err(ParseError::User { error: "bad f64 literal" })
    }
};

BoolLiteral: Box<PartialExpr> = {
    "true" => expr_box(BoolLiteral(true)),
    "false" => expr_box(BoolLiteral(false)),
};

Ident: Box<PartialExpr> = {
    <n:Name> => expr_box(Ident(n))
};

MakeVector: Box<PartialExpr> = {
    "[" <v:CommaSep<Expr>> "]" => {
        let v: Vec<PartialExpr> = v.into_iter().map(|b| *b).collect();
        expr_box(MakeVector(v))
    }
};

MakeStruct: Box<PartialExpr> = {
    "{" <v:CommaSep<Expr>> "}" => {
        let v: Vec<PartialExpr> = v.into_iter().map(|b| *b).collect();
        expr_box(MakeStruct(v))
    }
};

NewBuilder: Box<PartialExpr> = {
    "appender" <t:("[" <Type> "]")?> => {
        Box::new(PartialExpr {
            kind: NewBuilder,
            ty: Builder(Appender(t.unwrap_or(Box::new(Unknown))))
        })
    }
};

Merge: Box<PartialExpr> = {
   "merge" "(" <b:Expr> "," <v:Expr> ")" => expr_box(Merge(b, v))
};

Result: Box<PartialExpr> = {
   "result" "(" <b:Expr> ")" => expr_box(Res(b))
};

For: Box<PartialExpr> = {
   "for" "(" <d:Expr> "," <b:Expr> "," <f:Expr> ")" => expr_box(For(d, b, f))
};

If: Box<PartialExpr> = {
   "if" "(" <cond:Expr> "," <t:Expr> "," <f:Expr> ")" => expr_box(If(cond, t, f))
};

Name: Symbol = <s:r"[A-Za-z_][A_Za-z0-9_]*"> => s.to_string();

// Helper macro to read a comma-separated list 
CommaSep<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};
